import argparse
import subprocess
import os
import numpy as np
from geopy.distance import distance

from xml.dom import minidom
import xml.etree.ElementTree as ET

import matplotlib
import matplotlib.cm as cm
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from matplotlib.collections import LineCollection
from matplotlib.legend_handler import HandlerLineCollection
from matplotlib.backends.backend_pdf import PdfPages

import folium
from folium.features import DivIcon
from datetime import datetime, timedelta


class TrackData:
    def __init__(self):
        self.segments = []


class SegmentData:
    def __init__(self):
        self.datapoints = []


def _get_waypoint_data(waypoint):
    lap_string = waypoint.getElementsByTagName('name')[0].firstChild.data  # only one result
    lapnumber = lap_string.replace('LAP', '')
    lat = waypoint.getAttribute('lat')
    lon = waypoint.getAttribute('lon')
    data = {'LAP': lapnumber,
            'lat': lat,
            'lon': lon}
    return data


def get_waypoints_from_gpx(gpxfile):
    """ Waypoints are gps coords given by watch for laps """
    waypointdata = []
    for waypoint in minidom.parse(gpxfile).getElementsByTagName("wpt"):
        waypointdata.append(_get_waypoint_data(waypoint))
    return waypointdata


def _merge(file1, file2, outfile):
    "merges two gpx files, generated by different babel flags, into one"
    gpx1 = minidom.parse(file1)
    gpx2 = minidom.parse(file2)
    root = ET.Element("gpx", {'creator': "me", 'prog_used': "gpsbabel"})
    for waypoint in gpx1.getElementsByTagName('wpt'):
        _ = ET.SubElement(root, 'wpt', _get_waypoint_data(waypoint))

    outstr = ET.tostring(root)
    prettyxml = minidom.parseString(outstr)
    with open(outfile, "w") as f:
        f.write(prettyxml.toprettyxml(indent='\t', newl='\n'))


def convert_fit_to_gpx(fitfile):
    speedfile = '/tmp/speed.gpx'
    hrfile = '/tmp/hr.gpx'
    subprocess.call(["gpsbabel", "-t", "-i", "garmin_fit", "-x", "track,speed", "-f", fitfile,
                     "-o", "gpx", "-F", speedfile])
    subprocess.call(["gpsbabel", "-t", "-i", "garmin_fit", "-f", fitfile,
                     "-o", "gpx,garminextensions", "-F", hrfile])
    _merge(speedfile, hrfile, fitfile.replace('.fit', '.gpx'))


def process_gpx_file(filename):
    gpx = minidom.parse(filename)
    tracks = []
    for track in gpx.getElementsByTagName('trk'):
        tdata = TrackData()
        for tracksegment in track.getElementsByTagName('trkseg'):
            seg = SegmentData()
            for trackpoint in tracksegment.getElementsByTagName('trkpt'):
                seg.datapoints.append(get_data_from_point(trackpoint))
            tdata.segments.append(seg)
        tracks.append(tdata)
    return tracks


def get_data_from_point(trackpoint):
    lat = trackpoint.getAttribute('lat')
    lon = trackpoint.getAttribute('lon')
    ele = trackpoint.getElementsByTagName('ele')[0].firstChild.data
    time = trackpoint.getElementsByTagName('time')[0].firstChild.data
    speed = trackpoint.getElementsByTagName('speed')[0].firstChild.data
    atemp = trackpoint.getElementsByTagName('gpxtpx:atemp')[0].firstChild.data
    hr = trackpoint.getElementsByTagName('gpxtpx:hr')[0].firstChild.data
    cad = trackpoint.getElementsByTagName('gpxtpx:cad')[0].firstChild.data

    data = {
        'lat': float(lat),
        'lon': float(lon),
        'ele': float(ele),
        'atemp': float(atemp),
        'time': time,
        'hr': float(hr),
        'cad': float(cad),
        'speed': float(speed)
    }
    return data


def get_dist_gps(dp1, dp2):
    lat1 = dp1['lat']
    lon1 = dp1['lon']
    lat2 = dp2['lat']
    lon2 = dp2['lon']
    return distance((lat1, lon1), (lat2, lon2)).km


def _get_dist(dist_inc):
    dist = [0]
    for inc in dist_inc[1:]:
        dist.append(dist[-1] + inc)
    return dist


def gps_dist(flat):
    dist_inc = [0]
    for index, dp in enumerate(flat[1:]):
        dist_inc.append(get_dist_gps(flat[index], dp))
    return _get_dist(dist_inc)


def speed_dist(duration, speeds):
    dist_inc = [0]
    for i in range(len(duration) - 1):
        dt = duration[i+1] - duration[i]
        d = 1/2*(speeds[i] + speeds[i+1])*dt
        dist_inc.append(d)
    dist_meter = _get_dist(dist_inc)
    dist_km = [1/1000*d for d in dist_meter]
    return dist_km


def get_km_indices(dist):
    km = 1
    indices = []
    for i in range(len(dist) - 1):
        if dist[i] < km and dist[i+1] > km:
            indices.append(i)
            km += 1
    return indices


def interpolate_km(t1, t2, d1, d2):
    km1 = int(d1)
    km2 = int(d2)
    assert km1 is not km2
    dt = t2 - t1
    length = d2 - d1
    dx = km2 - d1
    return dx/length*dt, km2


def pacetime(seconds):
    minutes, rest = divmod(seconds, 60)
    seconds = int(rest)
    return f"{int(minutes)}:{int(seconds):02d}"


def flatten_tracks(tracks):
    flat = []
    num_tracks = int(len(tracks))
    print(f"have {num_tracks} tracks")
    for track in tracks:
        num_seg = int(len(track.segments))
        print(f"Track has {num_seg} segments")
        for seg in track.segments:
            flat = flat + seg.datapoints
    return flat


class HandlerColorLineCollection(HandlerLineCollection):
    """ see https://stackoverflow.com/questions/49223702/
            adding-a-legend-to-a-matplotlib-plot-with-a-multicolored-line """
    def create_artists(self, legend, artist, xdescent, ydescent,
                       width, height, fontsize, trans):
        x = np.linspace(0, width, self.get_numpoints(legend)+1)
        y = np.zeros(self.get_numpoints(legend)+1)+height/2.-ydescent
        points = np.array([x, y]).T.reshape(-1, 1, 2)
        segments = np.concatenate([points[:-1], points[1:]], axis=1)
        lc = LineCollection(segments, cmap=artist.cmap,
                     transform=trans)
        lc.set_array(x)
        lc.set_linewidth(artist.get_linewidth())
        return [lc]


def main():
    # fitfile = './B5CE0704.fit'
    # convert_fit_to_gpx(fitfile)

    gpxfile = './qmapshack_export.gpx'
    pdffile = gpxfile.replace('.gpx', '.pdf')
    # alpha: parameter to merge gps and speed based dist. d = alpha*gps_dist + (1-alpha)*speed_dist
    alpha = 1/2
    tracks = process_gpx_file(gpxfile)
    flat = flatten_tracks(tracks)

    datetimes = [datetime.strptime(dp['time'], '%Y-%m-%dT%H:%M:%S.000Z') for dp in flat]
    duration_sec = [(d - datetimes[0]).total_seconds() for d in datetimes]

    speeds_mps = [dp['speed'] for dp in flat]  # m/s
    # speeds_kmh = [3.6*s for s in speeds_mps]  # m/s to km/h
    paces = [(16+2/3)/dp['speed'] for dp in flat]  # m/s to min/km

    elevation = [dp['ele'] for dp in flat]

    dist_gps = gps_dist(flat)
    dist_speed = speed_dist(duration_sec, speeds_mps)
    dist = [alpha*d1 + (1 - alpha)*d2 for d1, d2 in zip(dist_gps, dist_speed)]
    # dist = dist_gps
    
    km_datetimes = []
    for i in get_km_indices(dist):
        dt, km = interpolate_km(duration_sec[i], duration_sec[i+1], dist[i], dist[i+1])
        km_datetimes.append(datetimes[i] + timedelta(seconds=dt))

    average_paces = [(km_datetimes[0] - datetimes[0]).total_seconds()]
    for index, time in enumerate(km_datetimes[1:]):
        average_paces.append((time - km_datetimes[index]).total_seconds())
    average_paces_minutes = [seconds/60 for seconds in average_paces]
    average_paces_strings = [pacetime(seconds) for seconds in average_paces]
    seconds_for_last_part = (datetimes[-1] - km_datetimes[-1]).total_seconds()

    for index, avp in enumerate(average_paces_strings):
        print(f"KM {index+1}: {avp}")
    print(f"Length: {dist[-1]:.2f}")
    total_time = (datetimes[-1] - datetimes[0]).total_seconds()/(60*60)  # in h
    total_time_h, r = divmod(total_time, 1)
    total_time_min, sec_percentage = divmod(60*r, 1)
    sec = sec_percentage*60
    total_time_str = f"{int(total_time_h)}:{int(total_time_min)}:{sec:.0f}"
    print("Time: " + total_time_str)
    average_pace = 60/(dist[-1]/total_time)
    avg_pace_min, r = divmod(average_pace, 1)
    avg_pace_sec = r*60
    avg_pace_str = f"{int(avg_pace_min)}:{avg_pace_sec:.0f}"
    print("Average pace: " + avg_pace_str)
    p1 = tracks[0].segments[0].datapoints[-1]
    p2 = tracks[0].segments[1].datapoints[0]
    offset = get_dist_gps(p1, p2)
    print(f"Offset due to multiple segments {offset}km")

    hr = [dp['hr'] for dp in flat]

    fig, ax = plt.subplots(figsize=(10, 5))
    # ax.set_ylim([100, 190])

    # ax.xaxis.set_major_formatter(mdates.DateFormatter('%H-%M'))
    # ax.xaxis.set_major_locator(mdates.MinuteLocator(interval=2))
    # ax.xaxis.set_minor_locator(mdates.SecondLocator(interval=30))

    # Times as x-ax:
    # duration_plot = [mdates.date2num(d) - mdates.date2num(datetimes[0]) for d in datetimes]
    # km_plot = [mdates.date2num(d) - mdates.date2num(datetimes[0]) for d in km_datetimes]

    # ax.plot(duration_plot, hr)
    # ax.plot(duration_plot, speeds_kmh)
    # ax.plot(duration_plot, elevation)
    # for km_time in km_plot:
    #     ax.plot([km_time, km_time], [0, 5], color='black')
    # fig.autofmt_xdate()

    # ax.plot(dist, average_pace_list, ls='--')
    hr = np.array(hr)
    elevation = np.array(elevation)
    points = np.array([dist, elevation]).T.reshape(-1, 1, 2)
    segments = np.concatenate([points[:-1], points[1:]], axis=1)
    cmap = plt.cm.jet
    lc = LineCollection(segments, cmap=cmap,
                        norm=plt.Normalize(min(hr), max(hr)))
    lc.set_array(hr)
    lc.set_linewidth(3)

    ax.set_title(f"Distance: {dist[-1]:.2f}, Time: {total_time_str}, avg pace: {avg_pace_str}")
    lowlim = 3
    ax.plot(dist, paces, label='pace')
    # ax.legend()
    handles, labels = ax.get_legend_handles_labels()
    ax.legend([lc] + handles, ["elevation/hr"]+labels,
              handler_map={lc: HandlerColorLineCollection(numpoints=6)},
              framealpha=1)
    # ax.legend([lc] + handles, ["elevation/hr"]+labels,
    #           handler_map={lc: HandlerColorLineCollection(numpoints=6),
    #                        paceline: HandlerLineCollection()},
    #           framealpha=1)
    ax.set_ylim([lowlim, 9])
    ax2 = ax.twinx()
    line = ax2.add_collection(lc)
    cb = fig.colorbar(line, location='left')
    ax2.set_ylim(elevation.min() - 10, elevation.max() + 10)
    for i, pace in enumerate(average_paces_strings):
        # ax.plot([i, i+1], [pace, pace], color='blue', ls='--')
        # ax.plot([i, i], [0, pace], color='blue', ls='--')
        # ax.plot([i+1, i+1], [0, pace], color='blue', ls='--')
        ax.text(i+1/5, lowlim + 0.1, pace)
    ax.text(int(dist[-1])+1/5, lowlim + 0.1, pacetime(seconds_for_last_part))
    ax.set_xticks([i for i in range(int(dist[-1])+1)] + [dist[-1]])
    ax.set_xticklabels([f'{i:.2f}' for i in (list(range(int(dist[-1])+1)) + [dist[-1]])])
    ax.set_xlabel('km')
    ax.set_ylabel('m/km')
    ax2.set_ylabel('m')
    cb.set_label('hr')
    ax.grid(True)
    fig.tight_layout()

    with PdfPages(pdffile) as export_pdf:
        export_pdf.savefig(fig)
    subprocess.call(["convert", "-density", "300", pdffile,
                     "-resize", "100%", pdffile.replace('.pdf', '.png')])
    # ax2.plot(dist, elevation, color='brown')

    # ax.format_xdata = mdates.DateFormatter('%M-%S')
    # plt.show()


if __name__ == "__main__":
    main()
